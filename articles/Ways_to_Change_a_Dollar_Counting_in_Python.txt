Ways to Change a Dollar: Counting in Python

Generating Functions and Series Multiplication Christoph Ostertag · Follow 3 min read · Oct 23, 2019 -- Listen Share

Easy example first: We want to know how many ways there are to get 20 cents from nickels and dimes.

Ever wondered if you can do series math and write algorithms for everything you learn in college math classes in Python code? I bet you can. Dump that obsolete calculator and stop searching for more powerful online calculators. How about you write your own program. Let’s do some discrete math.

Nickels: N = x⁰ + x⁵ + x¹⁰ + x¹⁵ + x²⁰ (Take a nickel 0, 1, 2, 3 or 4 times)

Dimes: D = x⁰ + x¹⁰ + x²⁰ (Take a dime 0, 1 or 2 times) Now just multiply the series element by element.

Coin combinations: (x⁰ + x⁵ + x¹⁰ + x¹⁵ + x²⁰) * (x⁰ + x¹⁰ + x²) =

x⁰ *( x⁰ + x¹⁰ + x²⁰) +

x⁵ (* x⁰ + x¹⁰ + x²⁰) +

x¹⁰ *( x⁰ + x¹⁰ + x²⁰) +

x¹⁵ (* x⁰ + x¹⁰ + x²⁰) +

x²⁰ (* x⁰ + x¹⁰ + x²⁰)

= x⁰ + x⁵+ 2x¹⁰ + 2x¹⁵ + 3x²⁰ Thus we know there are 3 different combinations of coins so that we get 20 cents. 2 dimes, 1 dime and 2 nickels or 4 nickels. Looks right!

Remark: (One combination for 0 and 5 cents, 2 for 10 and 15 cents)

1. First we import numpy

import numpy as np

2. Then we make lists for all the individual coin types

Python can not directly work with a power series like x¹, x², x³ …, but do not worry, we just encode the series as a list 1, 2, 3… instead.

(1+2=3 is similar to x¹+x²= x³)

cents = list(range(0,101,1)) # [0,1,2,3 ...,100]

nickels = list(range(0,105,5)) # [0,5,10,15 ...,100]

dimes = list(range(0,110,10)) # [0,10,20,30 ...,100]

quarters = list(range(0,125,25)) # [0,25,50,75,100] coins = [cents,nickels,dimes,quarters]

3. Writing a function for series multiplication: This is tough

Not the prettiest solution, but it works well. (This just does the series multiplication from above by adding powers and keeping track of the count)

def series_multiplication(powers):

powers = [np.array(p) for p in powers]

current_counts = np.ones(len(powers[0]))

current_powers = powers[0]

#current_counter = counters[0]

for p in powers[1:]:

# multiply each element from the first series with each element in the other series

powers_to_add = []

for e in p:

power_mult = [] #list(current_powers + e)

for cp,cc in list(zip(current_powers, current_counts)):

elements_to_add = [cp+e]*int(cc)

power_mult.extend(elements_to_add) # append each multiplied cp element cc times

powers_to_add.extend(power_mult)

current_powers, current_counts = np.unique(powers_to_add,return_counts=True)

return list(zip(current_powers, current_counts))

Results

Now that we have 1 dollar of every coin type (100 cents, 20 nickels, 10 dimes, 4 quarters) we get a count for every combination from 1 cent to 400 cents. (The output is shorted to make it more readable)

There are 242 ways to change 1 dollar!

series_multiplication(coins)

Output:

[(0, 1),

(1, 1),

(2, 1),

(3, 1),

(4, 1),

(5, 2), ...

(10, 4), ...

(20, 9), ...

(100, 242), ...

(400, 1)]

Thanks to my professor Donu Arapura at Purdue University for explaining the concept of generating functions so well.

If you appreciate the effort I put into this article and want to see more please 👏 this story and consider following my account.

Some of my other articles that might interest you