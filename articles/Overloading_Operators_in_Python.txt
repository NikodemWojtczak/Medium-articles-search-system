…and a bit on overloading in general (but I’ll try not to overload you)

Most of us learning to program in Python run into concepts behind operator overloading relatively early during the course of our learning path. But, like most aspects of Python (and other languages; and, for that matter, pretty much anything), learning about overloaded operators necessarily ties into other concepts, both broadening the scope of topic and somewhat obfuscating the route through our individual learning curve. With that in mind, I will try to keep on-topic without pulling in too many other areas of learning Python- some Object-Oriented Programming naturally ties in, however; and, while I’d like to focus on overloading operators, the broader, more complex topic of overloading functions also warrants at least some mention.

Overloading, in the context of programming, refers to the ability of a function or an operator to behave in different ways depending on the parameters that are passed to the function, or the operands that the operator acts on [1]. In Python, operator overloading (also known as “operator ad-hoc polymorphism”) in particular is a form of ‘syntactic sugar’ that enables powerful and convenient ways to prescribe an operator’s, er, operations, as an infix expression of specified types. Said another way, operator overloading gives extended meaning to operators beyond their pre-defined operational meaning.

Operator Overload examples for + and *

The classic operator-overloading example in Python is the plus sign, a binary (i.e., two operands) operator that not only adds a pair of numbers, but also concatenates a pair of lists or strings. The asterisk is similarly overloaded as not only a multiplier for numbers, but also as a repetition operator for lists or strings. Comparison operators (such as >, ==, or !=) exhibit similar behavior; however, for all of these overloaded operators, we as Python users ought be somewhat careful when considering type checking. As MIT’s Professor John Guttag reminds us, “type checking in Python is not as strong as in some other programming languages (e.g., Java), but it is better in Python 3 than in Python 2. For example, it is pretty clear what < should mean when it is used to compare two strings or two numbers. But what should the value of ‘4’ < 3 be? Rather arbitrarily, the designers of Python 2 decided that it should be False because all numeric values should be less than all values of type str. The designers of Python 3 and most other modern languages decided that since such expressions don’t have an obvious meaning, they should generate an error message.”[2]

This is all well and good, but what if an operator is being used on one or more user-defined data types (i.e., from a created class) as an operand? In such a case- say, attempting to add a pair of (x, y) coordinates, as shown here- the compiler will throw an error since it doesn’t know how to add the two objects. And, while overloading can only be done on existing operators in Python, there are a handful of them, along with the corresponding magic method each of these operators invoke; using these corresponding methods, we can create/access/edit their inner workings (see end of article).

Like other nomenclature in this rapidly-evolving field, there doesn’t seem to be a consensus on what to call them- they’re somewhat commonly referred to as “magic methods”- called “magic” since they’re not invoked directly- and that seems to be closest to standard, perhaps since the alternative “special method” sounds, well, not so special. Some herald a more colorful moniker- “dunder methods” as a shorthand for “double-underscore methods” (i.e., “dunder-init-dunder”). Anyhow, they’re a special type of method, and are not only limited to the methods associated with operators (__init__() or __call__(), as examples); in fact, there are quite a few of them.

Just as a quick aside- printing has its own associated magic method, __str__(). If we were to print the plain Point class with just the lone __init__(), we would get the not-so-user-friendly output shown above.

Adding the __str__() method into the Point class will remedy that. Interestingly, format() also invokes the same __str__() method that print() does.

A simple * overloading example using our cohort’s nickname (3x like the Thundercats, Schnarf Schnarf)

It turns out that using (x, y) coordinates to walk through examples of overloading, methods, and other Python concepts is a somewhat common practice when learning Python, probably since we get to create our own class with something as mathematically familiar as coordinate points. From there, one can create a number of useful magic methods for one’s user-defined class and use them to overload operators.

A noteworthy aspect of operator overloading is the position of each operand in relation to its operator. Take the less than operator < as an example- it calls the __lt__() method for the first (or left/preceding) operand. In other words, the expression x < y is shorthand for x.__lt__(y); if the first operand is a user-defined class, it needs to have its own corresponding __lt__() method in order to be able to use “<”. That may seem like a nuisance, but it actually adds some handy flexibility for designing one’s classes, since we could customize what any operator’s function does for a class. “In addition to providing the syntactic convenience of writing infix expressions that use <,” Professor Guttag points out, “this overloading provides automatic access to any polymorphic method defined using __lt__(). The built-in method sort is one such method.”[2]

In light of this distinction between first and second operands, Python also provides us with a set of reverse methods, such as __radd__(), __rsub__(), __rmul__(), and so on. Keep in mind that these reverse methods are only called if the left operand does not support the corresponding operation and the operands are of different types. A Pythonista redditor named Rhomboid explains it way better than I ever could, so I humbly defer to his take: