Let’s look at the methodology first. As I mentioned, I used the Twitter Public API to connect to the Twitter server and get all tweets that contained generic keywords, like ‘Trump’ or ‘impeachment’. The process was long, though, and it took my very caffeinated MacBook a couple of days to reach the 500k tweets mark (needless to say, it’s almost impossible to get anything done with the computer during those times). There are, of course, other ways to get around, like streaming the tweets in real-time, which is easier and less computationally expensive, but I could not go back in time that Friday afternoon, when it was too late to capture tweets live.

In order to connect to the Twitter API you need to create a developer profile and apply for a license. The process is not long and you will be equipped with your own license in no time if you do it right.

After having the tweets, it was time to do some network theory. Think about it: if every account participating in the conversation is represented as a point in space (say, a node) and if every time any one of them interacts with another via a reply, a retweet or a quote we draw a line between them, we would end up with a bunch of nodes linked together with what we’ll call edges. Thus we can represent the conversation that took place on December the 18th as a social network and, better yet, we can graph it to visually assess what’s going on.

An example of a network graph - Taken form the Gephi Blog on Wordpress.

My graphing tool was Gephi, an open source network graphing software (for which a ton of tutorials are available online). All you need to pass to Gephi is a simple csv file with two columns: the account that generated an interaction (the ‘source’ column) and the account that received said interaction (the ‘target’ column). After that, you are free to play around with your network and represent it any way you like. Here’s what I did:

Choose the ForceAtlas2 layout. Calculate the modularity score. Set node labels with a size proportional to each node’s in-degree.

Technical Interlude

Let’s revisit that, step by step:

First, the layout. There are several algorithms that calculate all sorts of fundamental aspects in a network, such as, how central certain nodes are, how far apart or close together should they be from each other, what clusters of nodes can be found in the network, how long or how elastic can the edges be, and so on. For the current graphing task, I chose ForceAtlas2, which, as the name suggests, is the sequel of ForceAtlas and is better equipped for larger networks. In essence, the algorithm takes on a couple of laws of physics to arrive at a stable state of balance or equilibrium between forces: it simulates the repulsion between nodes, as if they were charged particles (following Coulomb’s Law), while making the edges attract their nodes, just like springs (following Hooke’s Law).

Second, the modularity. It’s a way to detect communities within a network by giving a score that determines the strength of the divisions of the network into modules. High modularity means that a network has densely connected nodes within communities or modules, while links with other nodes in other communities or modules are rather loose or sparse.

Finally, the labelling. It’s crucial that we know which agents of the social network are the most relevant at a given time and so we can simply include their labels on the graph (for instance, their Twitter handlers). Imagine, though, a graph with hundreds of thousands of labels: it would look cluttered and unrecognizable. To solve that, we can simply ask Gephi to calculated the average weighted degree for each node.

The what now? The degree of a node is the sum of edges that interact with it: for instance, in our case, retweets an account has gotten or retweets an account has made. Given that our graph is, by nature, directed, we care a lot about which direction each action has. In other words, we care mostly about which account was retweeted the most (in-degree) or which account retweeted the most (out-degree). The weight of said degrees simply relates to the importance or the quality of the edges for a node. For example, when there has been repeated interaction between two specific nodes, that edge will have a higher weight and therefore its degree will be pondered given such weights. When you have the degrees, you can ask Gephi to label the nodes relative to their degrees, so that the most relevant ones within a network will be the most visible.