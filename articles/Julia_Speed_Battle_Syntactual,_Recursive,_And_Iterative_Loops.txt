With all of the writing i have been doing for the machine learning module, Lathe, and the new algorithms i have been implementing into 0.0.4, my mind has been set on optimization to really set the bar for speedy machine learning. A couple weeks ago, while working on a time-sensitive project, I was trying to build an algorithm from an enormous data-set with Python, and the Jupyter kernel would crash just from trying to read it in. On the other hand, I thought to my Julia experience, and without even having to go to Scala I was well able to read in data-sets with over thirty-five million observations, and time the predictions out to only a few seconds at the most with Lathe. It was a difficult concept to grasp that rather than hitting the limitations of the hardware that I was running on, I was hitting the limitations of the language.

This got me thinking about low-level algorithms and their place in the speed of calculation in the form of looping. After a-lot of thought, I set my mind to testing out the validity and severity of the well-known computer science ideologies about processing and language specifically in Julia. We all know that Julia doesn’t follow anybody’s rules, and really is a unique language in that regard. I have an article here on what you should know about Julia before using it for ML you can checkout for more information.

Assumptions

In the early day computing-sphere, typically iteration was always considered to be the fastest type of loop for manipulating and individualizing indices in an array. With this in mind, a lot of older systems could transfer less stacks with recursion than modern computers, for obvious reasons (mb of memory vs gb of memory), however a lot of the legacy languages from the 80’s are still moreso optimized for iteration over syntactual and recursive loops. It should also be noted that recursion is frequently frowned upon, and regarded as the slowest way to do a quick task. As for syntactual expressions, typically the result is completely dependent on your language and its compiler.